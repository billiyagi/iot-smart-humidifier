import { Elysia, t } from "elysia";
import { swagger } from "@elysiajs/swagger";
import { supabase } from "./lib/supabase";

const StatsSchema = t.Object({
  celcius: t.Object({
    daily: t.Array(t.Object({ time: t.String(), value: t.Number() })),
    weekly: t.Array(t.Object({ time: t.String(), value: t.Number() })),
    monthly: t.Array(t.Object({ time: t.String(), value: t.Number() }))
  }),
  humidity: t.Object({
    daily: t.Array(t.Object({ time: t.String(), value: t.Number() })),
    weekly: t.Array(t.Object({ time: t.String(), value: t.Number() })),
    monthly: t.Array(t.Object({ time: t.String(), value: t.Number() }))
  })
});

const app = new Elysia()
  .use(swagger({
    documentation: {
      info: {
        title: 'IoT Smart Humidifier API',
        version: '1.0.0',
        description: 'REST API for IoT Smart Humidifier system. Provides endpoints to manage temperature readings, humidity measurements, relay control states, and aggregated statistics.'
      },
      tags: [
        { name: 'General', description: 'General API endpoints' },
        { name: 'Temperature', description: 'Temperature reading management' },
        { name: 'Humidity', description: 'Humidity reading management' },
        { name: 'Relay', description: 'Relay control and state management' },
        { name: 'Statistics', description: 'Aggregated data and statistics' }
      ]
    }
  }))
  .get("/", () => "IoT Smart Humidifier API", {
    detail: { 
      summary: 'API Health Check',
      description: 'Returns API status and basic information.',
      tags: ['General']
    }
  })

  // Celcius Endpoints
  .post("/celcius", async ({ body, set }) => {
    const { error } = await supabase.from("celcius").insert(body);
    if (error) {
      set.status = 500;
      return { error: error.message };
    }
    return { success: true };
  }, {
    tags: ['Temperature'],
    body: t.Object({
      degrees: t.Integer({ 
        minimum: -50, 
        maximum: 100,
        description: 'Temperature in degrees Celsius (-50 to 100)'
      }),
    }),
    response: {
      200: t.Object({ 
        success: t.Boolean({ description: 'True if insertion successful' })
      }),
      500: t.Object({ error: t.String({ description: 'Error message' }) })
    },
    detail: { 
      summary: 'Create temperature reading',
      description: 'Stores a new temperature measurement in the database. The `degrees` field accepts integer values between -50 and 100. The `created_at` timestamp is automatically generated by the database.',
      examples: {
        'Valid request': {
          value: {
            degrees: 25
          }
        },
        'Success response': {
          value: {
            success: true
          }
        }
      }
    }
  })
  .get("/celcius", async ({ set }) => {
    const { data, error } = await supabase.from("celcius").select("*").order("created_at", { ascending: false });
    if (error) {
      set.status = 500;
      return { error: error.message };
    }
    return data;
  }, {
    tags: ['Temperature'],
    response: {
      200: t.Array(t.Object({
        id: t.Number({ description: 'Unique identifier' }),
        degrees: t.Integer({ description: 'Temperature in degrees Celsius' }),
        created_at: t.String({ description: 'ISO 8601 timestamp' })
      })),
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Get all temperature readings',
      description: 'Retrieves all temperature measurements from the database, sorted by `created_at` in descending order (newest first). Returns an array of temperature records with id, degrees, and timestamp.',
      examples: {
        'Success response': {
          value: [
            {
              id: 1,
              degrees: 25,
              created_at: "2025-12-26T10:30:00.000Z"
            },
            {
              id: 2,
              degrees: 24,
              created_at: "2025-12-26T10:25:00.000Z"
            }
          ]
        }
      }
    }
  })
  .delete("/celcius/:id", async ({ params: { id }, set }) => {
    const { error } = await supabase.from("celcius").delete().eq("id", id);
    if (error) {
      set.status = 500;
      return { error: error.message };
    }
    return { success: true };
  }, {
    tags: ['Temperature'],
    params: t.Object({
      id: t.Number({ description: 'Temperature record ID to delete' })
    }),
    response: {
      200: t.Object({ success: t.Boolean() }),
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Delete temperature reading',
      description: 'Deletes a temperature record by its ID. If the ID does not exist, the operation will still return success (Supabase behavior). Returns success object upon completion.',
      examples: {
        'Success response': {
          value: {
            success: true
          }
        }
      }
    }
  })

  // Humidity Endpoints
  .post("/humidity", async ({ body, set }) => {
    const { error } = await supabase.from("humidity").insert(body);
    if (error) {
      set.status = 500;
      return { error: error.message };
    }
    return { success: true };
  }, {
    tags: ['Humidity'],
    body: t.Object({
      percent: t.Integer({ 
        minimum: 0, 
        maximum: 100,
        description: 'Humidity percentage (0 to 100)'
      }),
    }),
    response: {
      200: t.Object({ success: t.Boolean() }),
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Create humidity reading',
      description: 'Stores a new humidity measurement in the database. The `percent` field accepts integer values between 0 and 100. The `created_at` timestamp is automatically generated by the database.',
      examples: {
        'Valid request': {
          value: {
            percent: 65
          }
        },
        'Success response': {
          value: {
            success: true
          }
        }
      }
    }
  })
  .get("/humidity", async ({ set }) => {
    const { data, error } = await supabase.from("humidity").select("*").order("created_at", { ascending: false });
    if (error) {
      set.status = 500;
      return { error: error.message };
    }
    return data;
  }, {
    tags: ['Humidity'],
    response: {
      200: t.Array(t.Object({
        id: t.Number({ description: 'Unique identifier' }),
        percent: t.Integer({ description: 'Humidity percentage (0-100)' }),
        created_at: t.String({ description: 'ISO 8601 timestamp' })
      })),
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Get all humidity readings',
      description: 'Retrieves all humidity measurements from the database, sorted by `created_at` in descending order (newest first). Returns an array of humidity records with id, percent, and timestamp.',
      examples: {
        'Success response': {
          value: [
            {
              id: 1,
              percent: 65,
              created_at: "2025-12-26T10:30:00.000Z"
            },
            {
              id: 2,
              percent: 63,
              created_at: "2025-12-26T10:25:00.000Z"
            }
          ]
        }
      }
    }
  })
  .delete("/humidity/:id", async ({ params: { id }, set }) => {
    const { error } = await supabase.from("humidity").delete().eq("id", id);
    if (error) {
      set.status = 500;
      return { error: error.message };
    }
    return { success: true };
  }, {
    tags: ['Humidity'],
    params: t.Object({
      id: t.Number({ description: 'Humidity record ID to delete' })
    }),
    response: {
      200: t.Object({ success: t.Boolean() }),
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Delete humidity reading',
      description: 'Deletes a humidity record by its ID. If the ID does not exist, the operation will still return success (Supabase behavior). Returns success object upon completion.',
      examples: {
        'Success response': {
          value: {
            success: true
          }
        }
      }
    }
  })

  // Relay Endpoints
  .post("/relay", async ({ body, set }) => {
    const { error } = await supabase.from("relay").insert(body);
    if (error) {
      set.status = 500;
      return { error: error.message };
    }
    return { success: true };
  }, {
    tags: ['Relay'],
    body: t.Object({
      reported_status: t.Union([t.Literal("ON"), t.Literal("OFF")], {
        description: 'Current relay status reported by hardware. ON = relay is active (humidifier running), OFF = relay is inactive.'
      }),
      mode: t.Union([t.Literal("AUTO"), t.Literal("MANUAL")], {
        description: 'Operating mode. AUTO = automatically controlled based on temperature/humidity thresholds. MANUAL = manually controlled by user.'
      }),
      manual_since: t.Optional(t.String({
        description: 'ISO 8601 timestamp indicating when manual mode was activated. Required only when mode is MANUAL.'
      })),
    }),
    response: {
      200: t.Object({ success: t.Boolean() }),
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Create relay state',
      description: `Creates a new relay state record. The relay controls the humidifier device.

**Fields:**
- \`reported_status\`: Actual hardware status (ON/OFF)
- \`mode\`: Operating mode (AUTO/MANUAL)
- \`manual_since\`: Optional timestamp for manual mode activation

**Modes:**
- **AUTO**: Relay status is automatically controlled based on temperature and humidity readings
- **MANUAL**: Relay status is manually set, \`manual_since\` should be provided

The \`updated_at\` timestamp is automatically generated.`,
      examples: {
        'AUTO mode': {
          value: {
            reported_status: "ON",
            mode: "AUTO"
          }
        },
        'MANUAL mode': {
          value: {
            reported_status: "OFF",
            mode: "MANUAL",
            manual_since: "2025-12-26T10:00:00.000Z"
          }
        },
        'Success response': {
          value: {
            success: true
          }
        }
      }
    }
  })
  .get("/relay", async ({ set }) => {
    const { data, error } = await supabase.from("relay").select("*").order("updated_at", { ascending: false });
    if (error) {
      set.status = 500;
      return { error: error.message };
    }
    return data;
  }, {
    tags: ['Relay'],
    response: {
      200: t.Array(t.Object({
        id: t.Number({ description: 'Unique identifier' }),
        reported_status: t.Union([t.Literal("ON"), t.Literal("OFF")], { description: 'ON = humidifier active, OFF = humidifier inactive' }),
        mode: t.Union([t.Literal("AUTO"), t.Literal("MANUAL")], { description: 'AUTO = automatic control, MANUAL = manual control' }),
        manual_since: t.Union([t.String(), t.Null()], { description: 'Timestamp if manual mode, null if auto' }),
        updated_at: t.String({ description: 'ISO 8601 timestamp of last update' })
      })),
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Get all relay states',
      description: `Retrieves all relay state records from the database, sorted by \`updated_at\` in descending order (newest first).

**Field Descriptions:**
- \`reported_status\`: ON (humidifier active) or OFF (humidifier inactive)
- \`mode\`: AUTO (automatic control) or MANUAL (manual control)
- \`manual_since\`: Timestamp when manual mode was activated, or null if in AUTO mode
- \`updated_at\`: Last time this state was recorded or updated`,
      examples: {
        'Success response': {
          value: [
            {
              id: 1,
              reported_status: "ON",
              mode: "AUTO",
              manual_since: null,
              updated_at: "2025-12-26T10:30:00.000Z"
            },
            {
              id: 2,
              reported_status: "OFF",
              mode: "MANUAL",
              manual_since: "2025-12-26T09:00:00.000Z",
              updated_at: "2025-12-26T10:25:00.000Z"
            }
          ]
        }
      }
    }
  })
  .get("/relay/:id", async ({ params: { id }, set }) => {
    const { data, error } = await supabase.from("relay").select("*").eq("id", id).single();
    if (error) {
      if (error.code === 'PGRST116') {
        set.status = 404;
        return { error: "Relay data not found" };
      }
      set.status = 500;
      return { error: error.message };
    }
    return data;
  }, {
    tags: ['Relay'],
    params: t.Object({
      id: t.Number({ description: 'Relay record ID to retrieve' })
    }),
    response: {
      200: t.Object({
        id: t.Number({ description: 'Unique identifier' }),
        reported_status: t.Union([t.Literal("ON"), t.Literal("OFF")], { description: 'ON = humidifier active, OFF = humidifier inactive' }),
        mode: t.Union([t.Literal("AUTO"), t.Literal("MANUAL")], { description: 'AUTO = automatic control, MANUAL = manual control' }),
        manual_since: t.Union([t.String(), t.Null()], { description: 'Timestamp if manual mode, null if auto' }),
        updated_at: t.String({ description: 'ISO 8601 timestamp of last update' })
      }),
      404: t.Object({ error: t.String({ description: 'Data not found message' }) }),
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Get single relay state by ID',
      description: `Retrieves a specific relay state record by its ID.

**Field Descriptions:**
- \`reported_status\`: ON (humidifier active) or OFF (humidifier inactive)
- \`mode\`: AUTO (automatic control) or MANUAL (manual control)
- \`manual_since\`: Timestamp when manual mode was activated, or null if in AUTO mode
- \`updated_at\`: Last time this state was recorded or updated

Returns 404 if the relay record is not found.`,
      examples: {
        'Success response': {
          value: {
            id: 1,
            reported_status: "ON",
            mode: "AUTO",
            manual_since: null,
            updated_at: "2025-12-26T10:30:00.000Z"
          }
        },
        'Not found response': {
          value: {
            error: "Relay data not found"
          }
        }
      }
    }
  })
  .patch("/relay/:id", async ({ params: { id }, body, set }) => {
    const { error } = await supabase.from("relay").update({ ...body, updated_at: new Date().toISOString() }).eq("id", id);
    if (error) {
      set.status = 500;
      return { error: error.message };
    }
    return { success: true };
  }, {
    tags: ['Relay'],
    params: t.Object({
      id: t.Number({ description: 'Relay record ID to update' })
    }),
    body: t.Object({
      reported_status: t.Optional(t.Union([t.Literal("ON"), t.Literal("OFF")], {
        description: 'New relay status (ON/OFF)'
      })),
      mode: t.Optional(t.Union([t.Literal("AUTO"), t.Literal("MANUAL")], {
        description: 'New operating mode (AUTO/MANUAL)'
      })),
      manual_since: t.Optional(t.Union([t.String(), t.Null()], {
        description: 'ISO 8601 timestamp for manual mode activation. Set to null when switching to AUTO mode.'
      })),
    }),
    response: {
      200: t.Object({ success: t.Boolean() }),
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Update relay state',
      description: `Updates an existing relay state record. All fields in the request body are optional - only include the fields you want to update.

**Common Update Scenarios:**
1. **Switch to MANUAL mode**: Set \`mode\` to "MANUAL" and provide \`manual_since\`
2. **Switch to AUTO mode**: Set \`mode\` to "AUTO" and \`manual_since\` to null
3. **Change status**: Update \`reported_status\` only

The \`updated_at\` timestamp is automatically updated to current time.`,
      examples: {
        'Switch to AUTO mode': {
          params: { id: 1 },
          value: {
            mode: "AUTO",
            manual_since: null
          }
        },
        'Switch to MANUAL mode': {
          params: { id: 1 },
          value: {
            mode: "MANUAL",
            manual_since: "2025-12-26T10:00:00.000Z",
            reported_status: "ON"
          }
        },
        'Update status only': {
          params: { id: 1 },
          value: {
            reported_status: "OFF"
          }
        },
        'Success response': {
          value: {
            success: true
          }
        }
      }
    }
  })

  // Statistics Endpoint
  .get("/statistik", async ({ set }) => {
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString();

    const [celciusRes, humidityRes] = await Promise.all([
      supabase.from("celcius").select("degrees, created_at").gte("created_at", thirtyDaysAgo).order("created_at", { ascending: true }),
      supabase.from("humidity").select("percent, created_at").gte("created_at", thirtyDaysAgo).order("created_at", { ascending: true })
    ]);

    if (celciusRes.error || humidityRes.error) {
      set.status = 500;
      return { error: celciusRes.error?.message || humidityRes.error?.message };
    }

    const processData = (data: any[], valueKey: string) => {
      const daily: Record<string, { sum: number; count: number }> = {};
      const weekly: Record<string, { sum: number; count: number }> = {};
      const monthly: Record<string, { sum: number; count: number }> = {};

      const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
      const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

      data.forEach(item => {
        const date = new Date(item.created_at);
        const val = item[valueKey];

        const dayKey = date.toISOString().split('T')[0];
        if (!monthly[dayKey]) monthly[dayKey] = { sum: 0, count: 0 };
        monthly[dayKey].sum += val;
        monthly[dayKey].count++;

        if (date >= sevenDaysAgo) {
          if (!weekly[dayKey]) weekly[dayKey] = { sum: 0, count: 0 };
          weekly[dayKey].sum += val;
          weekly[dayKey].count++;
        }

        if (date >= oneDayAgo) {
          const hourKey = date.toISOString().slice(0, 13) + ":00:00.000Z";
          if (!daily[hourKey]) daily[hourKey] = { sum: 0, count: 0 };
          daily[hourKey].sum += val;
          daily[hourKey].count++;
        }
      });

      const average = (record: Record<string, { sum: number; count: number }>) => 
        Object.entries(record).map(([key, { sum, count }]) => ({ time: key, value: sum / count }));

      return {
        daily: average(daily),
        weekly: average(weekly),
        monthly: average(monthly)
      };
    };

    return {
      celcius: processData(celciusRes.data, "degrees"),
      humidity: processData(humidityRes.data, "percent")
    };
  }, {
    tags: ['Statistics'],
    response: {
      200: StatsSchema,
      500: t.Object({ error: t.String() })
    },
    detail: { 
      summary: 'Get aggregated statistics',
      description: `Returns aggregated temperature and humidity data for visualization and analysis.

**Time Ranges:**
- **Daily**: Last 24 hours, grouped by hour (24 data points)
- **Weekly**: Last 7 days, grouped by day (7 data points)
- **Monthly**: Last 30 days, grouped by day (30 data points)

**Time Format:**
- **Daily**: ISO 8601 format (YYYY-MM-DDTHH:00:00.000Z) - hourly averages
- **Weekly**: YYYY-MM-DD format - daily averages
- **Monthly**: YYYY-MM-DD format - daily averages

**Use Cases:**
- Build charts and graphs for dashboard
- Analyze temperature/humidity trends
- Monitor historical patterns

**Example Response:**
\`\`\`json
{
  "celcius": {
    "daily": [
      {"time": "2025-12-26T08:00:00.000Z", "value": 24.5},
      {"time": "2025-12-26T09:00:00.000Z", "value": 25.2},
      {"time": "2025-12-26T10:00:00.000Z", "value": 24.8}
    ],
    "weekly": [
      {"time": "2025-12-20", "value": 25.0},
      {"time": "2025-12-21", "value": 24.8},
      {"time": "2025-12-22", "value": 25.3}
    ],
    "monthly": [
      {"time": "2025-12-01", "value": 24.5},
      {"time": "2025-12-02", "value": 25.1}
    ]
  },
  "humidity": {
    "daily": [
      {"time": "2025-12-26T08:00:00.000Z", "value": 65.5},
      {"time": "2025-12-26T09:00:00.000Z", "value": 66.2},
      {"time": "2025-12-26T10:00:00.000Z", "value": 65.8}
    ],
    "weekly": [
      {"time": "2025-12-20", "value": 62.3},
      {"time": "2025-12-21", "value": 63.1}
    ],
    "monthly": [
      {"time": "2025-12-01", "value": 63.7},
      {"time": "2025-12-02", "value": 64.2}
    ]
  }
}
\`\`\``
    }
  })
  .listen(3000);

console.log(
  `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`
);
